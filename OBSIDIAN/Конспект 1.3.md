Урок 3
Условные инструкции if
Самым распространенным условным ветвлением кода во всех языкахпрограммирования является инструкция **if** и Swift в этом случае неисключение. В самой простой форме данная инструкция имеет следующийсинтаксис:**if** condition {**some** code}После ключевого слова **if**, которое переводится, как «если», необходимо задатьусловие. Далее после пробела открывается фигурная скобка и на следующейстроке выполняется какое-то действие, если условие истинно. Ветвлениезаканчивается закрывающейся фигурной скобкой на следующей строке послекода.else ifif condition1 {**some** code}**else** **if** condition2 {**some** code} Инструкция **else** **if** используется для проверки следующего условия, в случаеесли первое условие **if** оказалось ложным. Если условие **else** **if** истинно, товыполняется код помещенный внутри фигурных скобок.Как только компилятор обнаружит условие, которое является истинным,проверка последующих условий прекращается и код в них не будет выполнен,даже если эти условияистины.elseif condition1 {**some** code}**else** **if** condition2 {**some** code}}**else** {**some** codeДанное ветвление содержит финальную инструкцию **else**, которая не содержитв себе ни каких условий и будет выполнена только в том случае, если всепредыдущие условия были ложными.Тернарный операторТернарный условный оператор — это оператор который состоит из трех частей.Синтаксис такого оператора имеет следующий вид: выражение ? действие1:действие2Switch statementОбычно мы используем инструкцию **if**, если наше условие достаточно про- стоеи предусматривает всего несколько вариантов. А вот инструкция switchподходит для более сложных условий, с множественными перестановками, и очень полезна в ситуациях, где по найденному совпадению с условиемвыбирается соответствующая ветка кода для исполнения.Инструкция **switch** подразумевает наличие какого-то значения, котороесравнивается с несколькими возможными шаблонами. После того как значениесовпало с каким-либо шаблоном, выполняется код, соответствующий от-ветвлению этого шаблона, и больше сравнения уже не происходит. switchпредставляет собой альтернативу инструкции **if**, отвечающей несколькимпотенциальным значениям.В самой простой форме в инструкции **switch** значение сравнивается содним или более значений того же типа:**switch** значение для сопоставления {**case** значение 1:инструкция для значения 1**case** значение 2, значение 3:инструкция для значения 2 или значения 3**default**:инструкция, если совпадений с шаблонами не найдено}После ключевого слова **switch** вписываем значение для сопоставления. Этозначение в отличии от инструкции **if** не должно возвращать булево значение.Т.е. тут мы указываем конкретное значение…Далее открываем тело ветвления при помощи фигурной скобки ипрописываем каждый возможный случай в кейсах, каждый из которыхначинается с ключевого слова caseКаждый отдельный блок **case** в **switch** — это отдельная ветка исполни-тельного кода. Инструкция **switch** определяет какое ветвление должно бытьвыбраноПосле того, как перечислены возможные варианты, последним блоком кодаидет условие, которое срабатывает, если не один из кейсов выше не соответствует значению для сопоставления. Такой случай по умолчанию называ-ется **default**, и он всегда идет после всех остальных случаев.По умолчанию после выполнения кейса в **switch** управление переходит наинструкции после **switch**, чтобы провалиться в следующий кейс нужно написать вконце **case** ключевое слово **fallthrough**. ПеречисленияОписание перечисленияПеречисление — это набор значений определенного типа данных,позволяющий взаимодействовать с этими значениями.Перечисление — это очень мощная концепция, позволяющая избежатьминорных ошибок при разработке приложений, она делает код чище и безопас-нее. По своей сути перечисление позволяют вам создавать списки возможныхзначений, который в дальнейшем могут быть использованы вами в различныхситуациях.Синтаксис перечисленийenum EnumirationName {**case** enumiration}После ключевого слова **enum** (от слова enumiration) с большой буквы пишем имяперечисления. В фигурных скобка после ключевого слова **case** пишемзначение.Также как и при работе с классами, создавая перечисление, вы создаетеновый тип данных.Значения перечислений можно перечислять через запятую, тогда видперечисления в целом будет иметь более компактный вид:**enum** Weekday {**case** monday, tuesday, wednesday,thursday, friday, saturday, sunday} В этом примере значения внутри перечисления имеют тип Weekday. Доступ кзначениям перечисления происходит через точку. Инициализацию значенияможно выполнить двумя способами Можно присвоить переменной тип данных, вкачестве которого выступает имя перечисления.var weekday: Weekdayweekday = Weekday.thursdayТак же можно сразу присвоить конкретный кейс из перечисления.var weekday = Weekday.thursdayВ том случае, если тип переменной соответствует перечислению (выше мыприсвоили переменной тип Weekday), то присваивая этой переменной какойлибо значения из перечисления, можно опустить само название перечисления ипросто выбрать нужный кейс поставив после знака присваивания точку.weekday = .mondayВозможности перечисленийswitch weekday {**case** .monday:print("To set the alarm for 8 am")**case** .tuesday:print("To set the alarm for 8:30 am")**case** .wednesday:print("To set the alarm for 8:30 am")**case** .thursday:print("To set the alarm for 7:30 am")**case** .friday:print("Yay! The last day of the week!")**default**:print("Weekend. Alarm not set")} Исходные значенияПеречислениям может быть присвоен определенный тип данных (String,Character, Int). В этом случае членам перечисления можно присвоить уникаль-ные исходные значения определенного типа, при этом все члены перечисле- ниябудут иметь один общий тип данных:**enum** Weekday: String {**case** monday = "To set the alarm for 8 am"**case** tuesday = "To set the alarm for 8:30 am"**case** wednesday = "To set the alarm for 9 am"**case** thursday = "To set the alarm for 7:30 am"**case** friday = "Yay! The last day of the week!"**case** saturdaycase sunday}**var** weekday = Weekday.mondayДля доступа к исходному значению члена перечисления существуетспециальное свойство:print(weekday.rawValue)Когда вы работаете с перечислениями, которые хранят целочисленные илистроковые исходные значения, можно не присваивать исходные значения явнодля каждого конкретного кейса. Swift автоматически сделает это за вас.weekday = .saturdayprint(weekday.rawValue)Weekday.saturday имеет неявное текстовое значение saturday. При этомесли в качестве исходных значений используются целые числа, неявноезначение для каждого кейса будет на единицу больше, чем в предыдущемкейсе. Если первый кейс не имеет заданного значения, его значение равно 0.7 **enum** Planet: Int {**case** mercury = 1, venus, earth, mars, jupiter, saturn,uranus, neptune}**var** somePlanet = Planet.earthprint("Earth is the \(somePlanet.rawValue) planet from the sun")Если объявить перечисление вместе с типом исходного значения, топеречисление автоматически получает инициализатор, который берет значениетипа исходного члена перечисления (как параметр rawValue) и возвращает либочлен перечисления либо **nil**. Вы можете использовать этот инициализатор,чтобы попытаться создать новый экземпляр перечисления.В этом примере Uranus инициализируется через его исходное значение7:Инициализацияlet possiblePlanet = Planet(rawValue: 7)print("The seventh planet is \(possiblePlanet!)")Типы данных так же можно присваивать каждому члену перечисления поотдельности. Члены перечисления могут хранить связанные значения любогонеобходимого типа. При этом набор связанных значений для каждого членаперечисления может быть произвольным.Связанные значения (ассоциированные параметры)**enum** Weekday {**case** workday(String, Int)**case** weekend(String)}Члены перечисления Weekday не имеют ни каких значений типа Int или String. Они лишь определяют типы связанных значений, которые переменные с типомWeekday могут содержать.var weekday = Weekday.workday("Set alarm to", 8)**switch** weekday {**case** .workday(**let** message, **let** time):print("\(message), \(time)")**case** .weekend(**let** weekendMessage):print("\(weekendMessage)")}Если все связанные значения для членов перечисления извлекаются какконстанты или переменные, то для краткости вы можете разместить одиночноеlet или **var** перед именем члена:**switch** weekday {**case** **let** .workday(message, time):print("\(message), \(time)")**case** .weekend(**let** weekendMessage):print("\(weekendMessage)") Опциональные типыОпциональные типы данных или просто опционалы — это еще одна осо-бенность языка Swift. Это такой особый тип данных, который говорит о том, чтопеременная или константа либо имеет значение определенного типа, либо **nil**.Самый простой пример: вам необходимо использовать в своем приложе-нии какие то данные полученные из сети. Для этого вы их сначала получаете, апотом используете по назначению. Но по ряду различных причин эти данныене всегда могут быть получены,или данные могут иметь не тот тип,который мыожидаем.Если мы обратимся к этим данным,ожидая получить от них значенияопределенного типа, то программа упадет с ошибкой в рантайме. Что бы при-ложение не падало по независимым от нас причинам, необходимо использо-вать опциональные типы. В этом случае, обратившись к опциональнойпере-менно, мы либо получим значение с нужным нам типом, либо **nil**.Опциональные типы имеют в конце знак вопроса, например Int?. Тип Int иInt?— это не одно и то же. Это два разных типа. Тип Int?это опциональныйинтерджер, который основан на типе Int. Знак вопроса в конце типа означа- ет,что это опциональный тип и он может принимать значения, как основного типа (внашем случае целочисленное число), так и **nil**. **nil** это специальное значение,которое говорит, что объект не имеет ни какого значения.Опциональную переменную можно установить в состояния отсутствия зна-чения, присвоив ей **nil**. **nil** можно присвоить только опциональным объек- там.Если вы считаете, что значение переменной или константы может отсут-ствовать, всегда присваивайте таким объектам опциональные типы. Опциональные переменные, если им не присвоить ни какого значения ав-томатически устанавливаются в nilИзвлечение опциональных типовКогда вы работаете с объектами опционального типа, вы можете не знать со-держит ли объект значение или нет. Поэтому прежде чем обратится к такомуобъекту надо проверить, есть ли в нем значение. Для этих целей можно ис-пользовать инструкцию ifсравнивая опционал с **nil**.if someOptionalValue == **nil** {print("someOptionalValue does not contains some value")}Если условие проверки на содержание значения в переменной истинно, то мыможем получить доступ к его значению, добавив восклицательный знак (!) в концеимени опционала. Восклицательный знак фактически говорит: «Я знаю точно,что этот опционал содержит значение, пожалуйста, используй его». Этовыражение известно как Принудительное извлечение значения опционала:**if** someOptionalValue != **nil** {print("someOptionalValue has some value of \(someOptionalValue!).")}Если применить принудительное извлечение ! к несуществующему опциональ-ному значению — это вызовет рантайм ошибку. Поэтому всегда прежде чем егоиспользовать, необходимо выполнить проверку на содержание значения.Привязка опционаловЧто бы постоянно не использовать восклицательный знак при обращении к оп-ционалу, можно из опционала извлечь значение и присвоить его временной переменной или константе, а далее работать с этой переменной. Такой спо-соб называется Привязкой опционалов. Прежде чем присвоить значение оп-ционалу переменной, необходимо проверить его на содержание этого значе-ния.if **let** currentValue = someOptionalValue {print(currentValue)}**else** {print("Error")}При извлечении функционала таким способом, мы присваиваем значение это- гофункционала другому объекту и в дальнейшем работаем уже с новым объ-ектом, который имеет явный тип. Поэтому использовать ! тут не нужно.Неявно извлеченные опционалыИногда, сразу понятно из структуры программы, что опционал всегда будет иметьзначение, после того как это значение впервые было установлено. В этихслучаях, очень полезно избавиться от проверки и извлечения значенияопционала каждый раз при обращении к нему, потому что можно с уверенно-стью утверждать, что он постоянно имеетзначение.Эти виды опционалов называются неявно извлеченные опционалы. Ихможно писать, используя восклицательный знак (String!), вместовопросительного знака (String?), после типа, который вы хотите сделатьопциональным.Неявно извлеченные опционалы полезны, когда известно, что значение оп-ционала существует непосредственно после первого объявления опционала, иточно будет существовать после этого. Вместо размещения восклицательного знака после имени опционала каж-дый раз, когда вы его используете, ставьте восклицательный знак после типаопционала вовремя его объявления.Не используйте неявно извлечённый опционал, если существует вероят-ность, что в будущем переменная может стать **nil**. Всегда используйте нор-мальный тип опционала, если вам нужно проверять на **nil** значение в течениесрока службы переменной.