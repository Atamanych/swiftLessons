Урок 6: 
Кортежи, классы, структуры, введение в ООПКортежиОдной из особенностью Swift является то, что одной переменной иликонстанте можно присвоить сразу несколько значений, но в отличии отмассива эти значения могут быть разных типов. Такие объекты называютсяTuples,что в переводе значит Кортежи.Кортежи - это группировка нескольких значений в одно составноезначениеУ каждого значения в составе кортежа может быть свой тип данных, который независит от других.Синтаксис(valueOne, ValueTwo, ValueThree,…)Для создания кортежа, значения, которые нужно сгруппировать,помеща-ются через запятую в круглые скобки. Количество значений в кортеже неограничено. var currentWeather = (22, "Sunny")В данном примере currentWeather это кортеж, который хранит в себе число22 и строку Sunny и описывает текущую погоду. Этот кортеж группирует всебе значения двух различных типов Int и String. Хотя кортеж и может хра-нить в себе значения различных типов, это не значит, что сам он не имеет типаданных. В данном конкретном случае работает вывод типа, так как компиляторможет вывести тип по значениям, которые вы присвоили, поэтому тип нашегокортежа (Int, String). При этом вы можете явно указать тип и создать кортежне присваивая ему значений:var currentWeather: (Int, String)currentWeatherVerTwo = (16, "Cloudy")Порядок указания значений должен соответствовать порядку указания типов, таккак если поменять местами значения или типы, то это уже будет кортеж другоготипа.Получение доступа к элементамcurrentWeather.0currentWeather.1currentWeather.0 = 24currentWeather.1 = "Rainy"Мы можем присвоить значения элементов из нашего кортежа новым пере-менным или константам. Переменные, которым присваиваются значения, за-писываются в скобках через запятую после ключевого слова var или let, приэтом количество переменных или констант должно соответствовать количе- ствуэлементов в кортеже.let (temperature, atmos) = currentWeather Значения элементов кортежа можно присваивать другим константам и пере-менным выборочно.Для этого необходимо заменить элементы,которые мы нехотим использовать, нижнимиподчеркиваниями.let (temperature, ) = currentWeatherИменование элементов кортежаТак же как и параметрам функций, элементам кортежа можно давать имена.Это бывает удобно, если необходимо обратиться к какому то элементукортежа, номер индекса которого мы не знаем. Доступ к элементам кортежапо имени удобнее и нагляднее, чем доступ через индексы.var weather = (temp: 21, atmos: "Fog", windSpeed: 6)Задать имена для отдельных элементов значений не получится. Еслиприсваиваете имя одному элементу, то придется присвоить имя и для всехостальных.Где используются кортежи?Кортежи полезны в любых местах где нужно группировать значения. Первый исамый простой способ использования кортежей — это массовое присвоение.Например выражение:var numberOne = 1var numberTwo = 2var numberThree = 3мы можем записать в одну строку:var (x, y, z) = (1, 2, 3) Еще одно применение кортежей - в циклах for...in. Возьмем для примера сло-варь cityTemp, в котором содержатся значения температуры в несколькихгородах :var cityTemp = ["Moscow": 6, "NewYork": 4, "London": 2, "LosAngeles": 22]Далее в цикле for in можно разложить пары словаря на отдельные значения иприсвоить их переменнымfor (cityName, temp) in cityTemp {print("Температура в городе \(cityName) сейчас равняется \(temp) градуса Цельсия")}Кроме этого, кортежи можно использовать как возвращаемое значение дляфункций.Кортежи не предназначены для создания сложных структур данных, ихпредназначение заключается в том, чтобы группировать однотипные илиразнотипные значения и передавать их в другое место. ООП в SwiftОбъектно-ориентированное программирование - это фундаментальная парадигмапрограммирования, которое берет своё начало с 1950-х годов и являетсяпроверенным способом построения сложных систем.Общее понятие ООПВ ООП все строится из объектов!Любая объектно-ориентированная программа — это наборвзаимодействующих друг с другом компонентов, которые называются объектами.В таких программах ответственность за работу всего приложения распределенамежду всеми объектами.Отдельный объект в программе является полностью самостоятельным иотвечает только сам за себя, а не за всю логику программы в целом. У каждогообъекта своё назначение и своя роль. Объекты могут представлять из себя, какобъекты реального мира, так и быть полностью абстрактными.Хорошо спроектированные и продуманные программы позволяют работатьнад отдельными её частями, не охватывая логику всей программы целиком.ООП так же позволяет упростить большие и сложные объекты, составляяих из более маленьких. Это в свою очередь позволяет упростить сложностьвсего приложения.ООП позволяет создавать новые объекты на базе уже существующих. Этопозволяет не переписывать каждый раз код заново, а дополнять ужесуществующий код новыми свойствами и методами. Этот механизм называетсянаследованием. Классы и объектыКласс — это фрагмент кода, у которого есть имя, класс(как и структура)определяет шаблон для построения объектов.class Name {}После ключевого слова class идет имя класса, которое выступает типом дляэкземпляров класса. Имя класса пишется с прописной буквы. Далее междуфигурными скобками располагаются элементы класса (свойства и методы).На основе одного класса мы можем создавать любое количествоэкземпляров класса (объектов), отличающихся между собой уникальнымименем.Создание объекта в программировании называется инициализацией.---Класс — это чертеж, по которому создается объектОбъект — это переменнаяИз одного класса можно создать множество подобных объектовОписание классаЛюбой класс может состоять только из двух составляющих. Это методы исвойства класса. Методы класса отвечают за поведение объекта, а свойства заего состояние.Свойства классаСвойства класса это константы и переменные, которые описывают объект. Виды методовМетод — это функция, которая отвечает за выполнение одного определенногодействия в классе и соответственно во всех его экземплярах. Методы не могутсуществовать вне классов, поэтому они и называются методы класса. Функциив отличии от методов, существуют вне классов и вообще к ним не привязаны.Все методы можно разделить на две большие группы:--метод экземпляраметод классаМетоды экземпляраДля того что бы вызвать такой метод, нам необходимо сначала создатьэкземпляр класса (объект) и обратившись к экземпляру класса, вызвать метод.Методы классаВ отличии от метода экземпляра, метод класса не возможно вызвать изэкземпляра класса. Для того, что бы его вызвать, необходимо обратитьсянапрямую к классу, а не к его объекту.ИнициализаторыХорошим примером метода класса является инициализатор. Задача этого методазаключается в создании объекта класса или можно сказать в инициализацииэкземпляра класса. Соответственно если бы инициализатор был методомэкземпляра, то мы бы просто не смогли его вызвать.Getter / SetterК методам класса также относятся геттеры и сеттеры. Эти методы устанавливают иполучают значения переменных. У каждой закрытой переменной есть свой гетер и сеттер. Гетеры — это публичные методы которые позволяют получать значенияпеременных, которые мы не видим. А сеттеры в свою очередь позволяют установитьновые значения для переменных. Структуры Синтаксис struct StructureName {var nameOfVarioable: DataTypefunc someFunction {some code}}Структуры объявляются с помощью ключевого слова stuct, после которогоследует имя создаваемой структуры. Так же как имена классов и перечислений,имена структур записываются в стиле камелкейс с прописной буквы. В телеструктуры, между фигурными скобками, описываются свойства и методы.Создавая структуру, вы определяете новый тип данных.Описание структурыТак же как и в классах, в структурах можно:---Объявлять свойства для хранения значенийОбъявлять методы, что бы обеспечить функциональностьОбъявлять инициализаторы, что бы обеспечить первоначальноезначение свойствНо в отличии от классов структуры не могут наследовать характеристики отдругих структур. Так же у структур, в отличии от классов нет деинициализато-ров. И пожалуй самым главным отличием структуры от класса является то, чтоструктуры не являются ссылочным типом. В отличии от классов, при созданииэкземпляра структуры, данные копируются в новую переменную или константу,а не передаются в нее по ссылке! Сравнение классов и структурИзучая классы, мы поняли, что класс является ссылочным типом:class MacBook {var name: Stringvar year: Intvar color: Stringinit(name: String, year: Int, color: String) {self.name = nameself.year = yearself.color = color}func specs() {print("\(name) \(year) \(color)")}}let myMac = MacBook(name: "MacBook Pro", year: 2015, color:"Silver")myMac.specs()let myWifesMac = myMacmyWifesMac.name = "MacBook Air"myWifesMac.specs()myMac.specs()Из этого примера видно, что наши константы это всего лишь ссылки наэкземпляр класса.Когда вы работаете с экземплярами структуры, это можно сравнить с работойв Microsoft Office. В этом случае работая например с Excel вы создаетелокальный файл у себя на компьютере. Поделившись этим файлом с другимпользователем, например по электронной почте, вы создаете копию своего файла. Это значит, что все внесенные в новый файл изменения ни как неотобразятся на вашем оригинальном файле. Так же как и внесенные изменения воригинальный файл, не найдут отражения в копии.struct SmartPhone {var name: Stringvar color: Stringvar capacity: Intfunc specs() {print("\(name) \(color) \(capacity)Gb")}}let myPhone = SmartPhone() Ошибка Обратите внимание, что в отличии от класса, я не могу создать экземплярструктуры без заданных значений. При этом мне не обязательно реализовыватьинициализатор для вызова значений по умолчанию. Структуры, так же какв перечисления, имеют встроенный инициализатор, который не требуетсяобъявлять. Данный инициализатор принимает на входе значения всех свойствструктуры, производит их инициализацию и создает экземпляр структурыlet myPhone = SmartPhone(name: "iPone 6", color: "Space Gray",capacity: 64)В результате создается новый экземпляр структуры, обладающий значениямивсех свойств. Значения всех свойств должны быть определены. Пропуститькакое либо из них не получится.Для свойств можно задать значения по умолчанию непосредственно в телеструктуры. В этом случае можно будет создавать экземпляр структуры безуказания значения свойств. При этом если вы решите задать значение поумолчанию хотя бы для одного свойства, то вам придется задать значения и длявсех остальных, т.к. Swift не позволяет определять значения по умолчанию лишьдля некоторых свойств. var myWifesPhone = myPhonemyWifesPhone.name = "iPhone SE"myWifesPhone.specs()myPhone.specs()Как видите, в отличии от примера с классом, поменяв значения второгоэкземпляра мы не изменили значения первого. В отличии от классов структуры -это типы-значения, т.е. при создании экземпляра структуры этот экземплярвсегда будет уникальным и при передаче параметров от одного экземпляраструктуры в другой происходит копирование. Так же обратите внимание на то,что создавая второй экземпляр структуры я присвоил ему ключевое слово var, вотличии от первого примера с классом, т.к. присвоив экземпляр кон-станте мыуже не сможем поменять значения свойств.Методы в структурахСоздадим новую структуру Rectanglestruct Rectangle {var width: Intvar height: Intfunc aria() -> Int {return width * height}}let myRectangle = Rectangle(width: 10, height: 5)myRectangle.aria()Итак наша структура позволяет рассчитать площадь прямоугольника. Давайтедобавим метод, который будет позволять нам увеличивать стороныпрямоугольника в нужное число раз.struct Rectangle {var width: Int var height: Intfunc aria() -> Int {return width * height}func scale(w: Int, h: Int) {width = w // Errorheight = h // Error}}По умолчанию методы структур, кроме инициализаторов, не могут изменятьзначения свойств. Для того что бы обойти это ограничение, перед именемобъявляемого метода необходимо указать модификатор mutating.struct Rectangle {var width: Intvar height: Intfunc aria() -> Int {return width * height}mutating func scale(w: Int, h: Int) {width = wheight = h}}let myRectangle = Rectangle(width: 10, height: 5)myRectangle.aria()myRectangle.scale(w: 2, h: 3) // ErrorСтруктура может изменять значения свойств только в том случае, еслиэкземпляр структуры хранится в переменнойvar myRectangle = Rectangle(width: 10, height: 5)myRectangle.aria()myRectangle.scale(w: 2, h: 3)myRectangle.aria()