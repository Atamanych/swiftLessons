Урок 4
## Типы коллекций 

Коллекции используются для хранения наборов значений. В Swift используется три типа коллекций - это Массивы, Словари и Множества. Массивы могут хранить в себе упорядоченные, не уникальные значения одного типа. Множества хранят в себе неупорядоченные, уникальные значения одного типа. Словари - это неупорядоченные коллекции, которые хранят в себе пары «ключ-значение». Тип ключа словаря может отличаться от типа значения. При этом сами ключи и значения должны быть одного типа.  
Когда вы создаете какую либо коллекцию, то вы присваиваете её какой-то константе или переменной. В зависимости от этого коллекции могут быть изменяемыми или неизменными.  

### Массивы 

Массивы — это коллекции, в которых могут храниться значения одного типа. Эти значения могут быть не уникальными, но всегда упорядоченными. Все значения в массиве хранятся по индексу в определенном порядке. Нумерация индексов начинается с нуля.  
Значения внутри массива заключаются в квадратные скобки и отделены между собой запятыми.  
Обратившись к массиву, можно вызвать логическое свойство **isEmpty**, которое позволяет узнать, является ли данный массив пустым или нет. 

### Множества 

Отличием множества от массива является то, что множества хранят в себе уникальные значения одного типа в неупорядоченном виде. Вы можете использовать множества в том случае, если хотите быть уверены в том, что значения элементов внутри множества не повторяются. В отличии от массивов множества не имеют сокращенной формы записи, поэтому для того, что бы создать множество, а не массив, необходимо указать тип коллекции **Set** при создании коллекции. 
Можно проверить наличие определенного элемента во множестве, используя метод contains() 
Так как элементы внутри множества хранятся в неупорядоченном виде, то для того, что бы у вас была возможность делать итерации при переборе элементов внутри коллекции, необходимо сортировать данные внутри множества. Для этого нужно использовать метод sorted(), который возвращает вам элементы коллекции в виде отсортированного массива, используя оператор <. Т.е. это сортировка происходит от меньшего к большему  
Кроме того, что элементы множества хранятся в неотсортированном виде, еще одной особенностью сетов, является уникальность всех значений. Эта особенность даёт нам дополнительные возможности для сравнения двух сетов между собой. Вы можете очень эффективно использовать базовые операции множеств, например, комбинирование двух множеств, определение общих значений двух множеств, определять содержат ли множества несколько, все или ни одного одинаковых значения. 

![](file:////Users/vladimir/Library/Containers/com.kingsoft.wpsoffice.mac.global/Data/tmp/wps-vladimir/ksohtml//wps3.png)

Данная иллюстрация изображает два множества **a** и **b** в результате применения различных методов. 

- Метод intersection() позволяет создать новое множество из общих значений двух входных множеств. 
- Метод symmetricDifference() используется для создания нового множества из значений, которые не повторяются в двух входных множествах. 
- Используйте метод union() для создания нового множества состоящего из всех значений обоих множеств. 
- И метод subtracting() для создания множества со значениями не принадлежащих второму множеству из двух сравниваемых. 

![](file:////Users/vladimir/Library/Containers/com.kingsoft.wpsoffice.mac.global/Data/tmp/wps-vladimir/ksohtml//wps4.png)

Иллюстрация выше отображает три множества **a**, **b** и **c**. Множество **a** является надмножеством множества **b**, так как содержит все его элементы, соответственно множество **b** является подмножеством множества **a**, опять таки потому, что все его элементы находятся в **a**. Множества **b** и **c** называются разделенными, так как у них нет общих элементов. 

- Можно использовать оператор равенства ( == ) что бы определить все ли значения двух множеств одинаковы. 
- Метод isSubset(of:) используется для определения все ли значения множества содержаться в указанном множестве. 
- Метод isSuperset(of:), используется чтобы определить содержит ли множество все значения указанного множества. 
- Т а к и е м е т о д ы , к а к isStrictSubset(of:) и л и isStrictSuperset(of:) используется для определения является ли множество подмножеством или надмножеством, но не равным указанному сету. 
- Для того, что бы определить есть ли у двух множеств общие значения используется метод isDisjoint(with:) 

### Словари 

Словари - это такие коллекции, которые хранят в себе однотипные значения. Каждое значение связано с уникальным ключом, который выступает в качестве идентификатора этого значения внутри словаря. Ключи так же, как и значения должны быть одного типа, но при этом их тип может отличаться от типа значений. Зная ключ, можно извлечь значение из словаря. Так же как и во множествах, элементы словаря не имеют определенного порядка.  
Поскольку есть вероятность запросить ключ для несуществующего значения, индекс словаря возвращает опциональное значение соответствующее типу значений словаря. Если словарь содержит значение для запрошенного ключа, индекс возвращает опциональное значение, содержащее существующее значение для этого ключа. В противном случае индекс возвращает nil: В остальном работа со словарями такая же, как и с массивами. 

### Циклы 

#### for-in циклы 

Циклы относятся к операторам управления потоком. Они используются для многократного выполнения задач и делятся на **for in** циклы и **while** циклы 
Цикл for-in используется для итерации по коллекциям элементов, таких как диапазоны чисел, элементы массива, элементы словаря и множеств, символов в строке и других последовательностей. 
Циклы используются тогда, когда возникает необходимость повторить какой то кусок кода несколько раз. Каждый такой проход и называется итерацией. Количество итераций может зависеть от заданного вами диапазона, либо же пока не удовлетворится условие, например пока не найдется определенный элемент в массиве. 

Синтаксис цикла for in: 

```
for counter in lower…upper {
	some code 
} 
```

Цикл начинается с ключевого слова **for**, далее идет переменная **counter**, которая принимает значение из диапазона при каждой итерации. Количество повторов зависит от диапазона от **lower** до **upper**. К примеру если диапазон составляв от 1 до 5, то код заключенный между фигурными скобками повторится 5 раз. Так в нашем примере **counter** при каждой итерации будет меняться с **lower** до **upper**  

#### While 

Цикл **while** выполняет набор инструкций до тех пор, пока его условие не станет **false**. Этот вид циклов лучше всего использовать в тех случаях, когда количество итераций неизвестно. Swift предлагает два вида циклов **while**:  

- while - вычисляет условие выполнения в начале каждой итерации цикла. 
- repeat-while - вычисляет условие выполнения в конце каждой итерации цикла. 

Так выглядит синтаксис **while** цикла: 

```
while condition {
	some code
}
```

Расшифровать его можно так: Если наше условие истинно, выполняем инструкцию, находящуюся между двумя фигурными скобками. После выполнения инструкции снова проверяем условие. Если оно истинно, то еще раз выполняем код, внутри цикла и так до тех пора, пока наше условие не станет **false**.  

#### Repeat-While 

```
repeat {     
	some code 
} while condition
```

В отличии от предыдущего цикла этот цикл всегда будет выполнен, как минимум один раз, в не зависимости от того, истинно заданное условие или нет. Как видите в этом цикле первым идет ключевое слово **repeat**. В данном контексте его можно интерпретировать, как **выполнить**. Далее между фигурными скобками помещается код, который необходимо выполнить. После того, как инструкция выполнена, идет проверка на истинность условия. Если оно истинно, то цикл запускается снова и так до тех пор, пока условие не станет **false**. Из за того, что проверка условия происходит в конце, код будет выполнен, как минимум один раз, при первом запуске цикла.


# CLASSROOM WORK

```
import UIKit

  
//: # Урок 4. Типы коллекций


//: ## Массивы


Хранят в себе упорядоченные, но при этом не уникальные значения одного типа


// Неизменяемый массив с типом данных String
let strings = ["a", "b", "c"]
  
// Неизменяемый массив с типом данных Character
let characters: [Character] = ["a", "b", "c"]

// Пустой массив с типом Int
var integers: [Int] = []

// Присваивание данных массиву
integers = [1, 2, 3]

// Теперь наш массив имеет другие данные
integers = [4, 5, 6] 

// Добавление новых значений к уже существующим
integers += [7, 8]  

// Добавление нового значения при помощи метода append
integers.append(9)

// Добавление нового элемента по индексу
integers.insert(1, at: 0)

// Создание нового массива, путём объединения двух других массивов
var someIntegers = integers + [12, 17]

//Удаление последнего элемента из массива
someIntegers.removeLast()

//Удаление последнего элемента из массива и сохранение его в константе
let lastValueFromArray = someIntegers.removeLast()

//Результат после удаления последнего элемента
someIntegers

//Удаление первого элемента из массива и сохранение его в константе
someIntegers.removeFirst()

// Результат после удаления первого элемента
someIntegers

// Удаление значения по индексу
someIntegers.remove(at: 1)

// Результат после удаления значение по индексу
someIntegers

// Количество элементов массива
someIntegers.count

// Удаление всех элементов массива
someIntegers.removeAll()

// Обнуление массива путём присваивания ему пустого массиву
integers = []

integers = [10, 20, 40]  

// Поиск индекса, по которому храниться элемент
integers.firstIndex(of: 40)

// Замена значения по заданному индексу на новое значение
integers[2] = 30

// Результат после замены
integers


//: ### Использование логического свойства isEmpty


if !integers.isEmpty {
    integers.remove(at: 0)
}


//: ## Множества


Хранят в себе неупорядоченные, но при этом уникальные значения одного типа

// Создание множества с типом String
let strings: Set = ["a", "a", "a", "b", "c"]

// Создание пустого множества с типом Character
var characters: Set<Character> = []

// Добавление нового элемента в множество
characters.insert("b")
characters.insert("b")

// Проверка на наличие определенного элемента во множестве
characters.contains("b")

// Сортировка с использованием метода sorted() для последующей итерации по множеству
characters = ["a", "a", "a", "b", "c"]
let chars = characters.sorted(by: >)


//: ## Словари


Неупорядоченные коллекции, которые хранят в себе пары «ключ-значение». Тип ключа словаря может отличаться от типа значения. При этом сами ключи и значения должны быть одного типа

// Словарь с типом [Int: String]
let users = [1: "Tim Cook", 2: "Taylor Swift"]

// Создание пустого словаря с типом [String: String]
var carWashQueue: [String: String] = [:]

// Наполнение словаря данными
carWashQueue = ["EO92BA": "Red Toyota", "X127MT": "Gray BMW X6"]

// Изменение значения для ключа
carWashQueue["EO92BA"] = "Red Camry"

// Изменение значения с сохранением старого значения
let oldValue = carWashQueue.updateValue("White BMW X6", forKey: "X127MT") 

// Добавление новой пары ключ-значение
carWashQueue["M566PA"] = "Green Chavralet Niva"

// Удаление значения по ключу с сохранением значения
carWashQueue.removeValue(forKey: "EO92BA") 

carWashQueue.count
carWashQueue.removeAll()


//: ## Строки

  
let string = String(["H", "e", "l", "l", "o"])
	print(string)
  
string.count
string.contains("h")


//: ## For-in циклы


for counter in lower…upper {
        some code
    }
    
 
var total = 0
for number in 1...5 {
    total += number
}

print(total)
  

//: ### Итерация по массиву


let fruits = [
    "apple",
    "banana",
    "pineapple",
    "apple",
    "pear",
    "apple",
    "plum",
    "apricot",
    "apple"
]
var appleCount = 0
for fruit in fruits {
    if fruit == "apple" {
        appleCount += 1
    }
}

print("The number of apples is \(appleCount) pieces")
  

//: ### Итерация по словарю


let numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
for (animal, legCount) **in** numberOfLegs {
    print("\(animal)s have \(legCount) legs")
}

  
//: ### Итерация по тексту


let greeting = "Hello!"
for char in greeting {
    print(char)
}


//: ## While циклы


    while condition {
        some code
    }

  
var counter = 0
while counter < 5 {
    print("Counter is \(counter)")
    counter += 1
}

counter


	repeat {
        some code
    } while condition


repeat {
    print("Counter is \(counter)")
    counter += 1
} while counter < 5

counter

```